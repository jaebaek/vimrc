{"file_info_response":[{"return_code":1,"file_info":{"name":"src/net/url_request/url_request_http_job.h","lines":"274","size":"10434","language":"c++","type":1,"md5":"bcf52a5e3e2f84d272dc8b7f46b7a625","changelist_num":"fe199f4407a2d90e1cd7d95b072896f17cfd0f97","mime_type":"text/plain","generated":false,"package_name":"chromium","content":{"text":"// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#ifndef NET_URL_REQUEST_URL_REQUEST_HTTP_JOB_H_\n#define NET_URL_REQUEST_URL_REQUEST_HTTP_JOB_H_\n\n#include \u003cstddef.h\u003e\n#include \u003cstdint.h\u003e\n\n#include \u003cmemory\u003e\n#include \u003cstring\u003e\n\n#include \"base/compiler_specific.h\"\n#include \"base/macros.h\"\n#include \"base/memory/weak_ptr.h\"\n#include \"base/time/time.h\"\n#include \"net/base/auth.h\"\n#include \"net/base/completion_callback.h\"\n#include \"net/base/net_error_details.h\"\n#include \"net/base/net_export.h\"\n#include \"net/base/sdch_manager.h\"\n#include \"net/cookies/cookie_store.h\"\n#include \"net/filter/sdch_policy_delegate.h\"\n#include \"net/http/http_request_info.h\"\n#include \"net/socket/connection_attempts.h\"\n#include \"net/url_request/url_request_job.h\"\n#include \"net/url_request/url_request_throttler_entry_interface.h\"\n\nnamespace net {\n\nclass HttpRequestHeaders;\nclass HttpResponseHeaders;\nclass HttpResponseInfo;\nclass HttpTransaction;\nclass HttpUserAgentSettings;\nclass ProxyInfo;\nclass SSLPrivateKey;\nclass UploadDataStream;\n\n// A URLRequestJob subclass that is built on top of HttpTransaction. It\n// provides an implementation for both HTTP and HTTPS.\nclass NET_EXPORT_PRIVATE URLRequestHttpJob : public URLRequestJob {\n public:\n  static URLRequestJob* Factory(URLRequest* request,\n                                NetworkDelegate* network_delegate,\n                                const std::string\u0026 scheme);\n\n  // Record Sdch specific packet stats. Public so that SdchPolicyDelegate can\n  // access it.\n  void RecordPacketStats(SdchPolicyDelegate::StatisticSelector statistic) const;\n\n protected:\n  URLRequestHttpJob(URLRequest* request,\n                    NetworkDelegate* network_delegate,\n                    const HttpUserAgentSettings* http_user_agent_settings);\n\n  ~URLRequestHttpJob() override;\n\n  // Overridden from URLRequestJob:\n  void SetPriority(RequestPriority priority) override;\n  void Start() override;\n  void Kill() override;\n  void GetConnectionAttempts(ConnectionAttempts* out) const override;\n  std::unique_ptr\u003cSourceStream\u003e SetUpSourceStream() override;\n\n  RequestPriority priority() const {\n    return priority_;\n  }\n\n private:\n  enum CompletionCause {\n    ABORTED,\n    FINISHED\n  };\n\n  typedef base::RefCountedData\u003cbool\u003e SharedBoolean;\n\n  class SdchContext;\n\n  // Shadows URLRequestJob's version of this method so we can grab cookies.\n  void NotifyHeadersComplete();\n\n  void DestroyTransaction();\n\n  void AddExtraHeaders();\n  void AddCookieHeaderAndStart();\n  void SaveCookiesAndNotifyHeadersComplete(int result);\n\n  // Processes the Strict-Transport-Security header, if one exists.\n  void ProcessStrictTransportSecurityHeader();\n\n  // Processes the Public-Key-Pins header, if one exists.\n  void ProcessPublicKeyPinsHeader();\n\n  // Processes the Expect-CT header, if one exists. This header\n  // indicates that the server wants the user agent to send a report\n  // when a connection violates the Expect CT policy.\n  void ProcessExpectCTHeader();\n\n  // Processes the Report-To header, if one exists. This header configures where\n  // the Reporting API (in //net/reporting) will send reports for the origin.\n  void ProcessReportToHeader();\n\n  // |result| should be OK, or the request is canceled.\n  void OnHeadersReceivedCallback(int result);\n  void OnStartCompleted(int result);\n  void OnReadCompleted(int result);\n  void NotifyBeforeStartTransactionCallback(int result);\n  void NotifyBeforeSendHeadersCallback(const ProxyInfo\u0026 proxy_info,\n                                       HttpRequestHeaders* request_headers);\n\n  void RestartTransactionWithAuth(const AuthCredentials\u0026 credentials);\n\n  // Overridden from URLRequestJob:\n  void SetUpload(UploadDataStream* upload) override;\n  void SetExtraRequestHeaders(const HttpRequestHeaders\u0026 headers) override;\n  LoadState GetLoadState() const override;\n  bool GetMimeType(std::string* mime_type) const override;\n  bool GetCharset(std::string* charset) override;\n  void GetResponseInfo(HttpResponseInfo* info) override;\n  void GetLoadTimingInfo(LoadTimingInfo* load_timing_info) const override;\n  bool GetRemoteEndpoint(IPEndPoint* endpoint) const override;\n  int GetResponseCode() const override;\n  void PopulateNetErrorDetails(NetErrorDetails* details) const override;\n  bool CopyFragmentOnRedirect(const GURL\u0026 location) const override;\n  bool IsSafeRedirect(const GURL\u0026 location) override;\n  bool NeedsAuth() override;\n  void GetAuthChallengeInfo(scoped_refptr\u003cAuthChallengeInfo\u003e*) override;\n  void SetAuth(const AuthCredentials\u0026 credentials) override;\n  void CancelAuth() override;\n  void ContinueWithCertificate(\n      scoped_refptr\u003cX509Certificate\u003e client_cert,\n      scoped_refptr\u003cSSLPrivateKey\u003e client_private_key) override;\n  void ContinueDespiteLastError() override;\n  int ReadRawData(IOBuffer* buf, int buf_size) override;\n  void StopCaching() override;\n  bool GetFullRequestHeaders(HttpRequestHeaders* headers) const override;\n  int64_t GetTotalReceivedBytes() const override;\n  int64_t GetTotalSentBytes() const override;\n  void DoneReading() override;\n  void DoneReadingRedirectResponse() override;\n\n  HostPortPair GetSocketAddress() const override;\n  void NotifyURLRequestDestroyed() override;\n\n  void RecordTimer();\n  void ResetTimer();\n\n  void UpdatePacketReadTimes() override;\n\n  // Starts the transaction if extensions using the webrequest API do not\n  // object.\n  void StartTransaction();\n  // If |result| is OK, calls StartTransactionInternal. Otherwise notifies\n  // cancellation.\n  void MaybeStartTransactionInternal(int result);\n  void StartTransactionInternal();\n\n  void RecordPerfHistograms(CompletionCause reason);\n  void DoneWithRequest(CompletionCause reason);\n\n  // Callback functions for Cookie Monster\n  void SetCookieHeaderAndStart(const CookieList\u0026 cookie_list);\n\n  // Some servers send the body compressed, but specify the content length as\n  // the uncompressed size. If this is the case, we return true in order\n  // to request to work around this non-adherence to the HTTP standard.\n  // |rv| is the standard return value of a read function indicating the number\n  // of bytes read or, if negative, an error code.\n  bool ShouldFixMismatchedContentLength(int rv) const;\n\n  // Returns the effective response headers, considering that they may be\n  // overridden by |override_response_headers_|.\n  HttpResponseHeaders* GetResponseHeaders() const;\n\n  RequestPriority priority_;\n\n  HttpRequestInfo request_info_;\n  const HttpResponseInfo* response_info_;\n\n  // Auth states for proxy and origin server.\n  AuthState proxy_auth_state_;\n  AuthState server_auth_state_;\n  AuthCredentials auth_credentials_;\n\n  bool read_in_progress_;\n\n  std::unique_ptr\u003cHttpTransaction\u003e transaction_;\n\n  // This is used to supervise traffic and enforce exponential\n  // back-off. May be NULL.\n  scoped_refptr\u003cURLRequestThrottlerEntryInterface\u003e throttling_entry_;\n\n  // A handle to the SDCH dictionaries that were advertised in this request.\n  // May be null.\n  std::unique_ptr\u003cSdchManager::DictionarySet\u003e dictionaries_advertised_;\n\n  // For SDCH latency experiments, when we are able to do SDCH, we may enable\n  // either an SDCH latency test xor a pass through test. The following bools\n  // indicate what we decided on for this instance.\n  bool sdch_test_activated_;  // Advertising a dictionary for sdch.\n  bool sdch_test_control_;    // Not even accepting-content sdch.\n\n  // For recording of stats, we need to remember if this is cached content.\n  bool is_cached_content_;\n\n  base::Time request_creation_time_;\n\n  // Data used for statistics gathering. This data is only used for histograms\n  // and is not required. It is only gathered if packet_timing_enabled_ == true.\n  //\n  // TODO(jar): improve the quality of the gathered info by gathering most times\n  // at a lower point in the network stack, assuring we have actual packet\n  // boundaries, rather than approximations. Also note that input byte count\n  // as gathered here is post-SSL, and post-cache-fetch, and does not reflect\n  // true packet arrival times in such cases.\n\n  // Enable recording of packet arrival times for histogramming.\n  bool packet_timing_enabled_;\n  bool done_;  // True when we are done doing work.\n\n  // The number of bytes that have been accounted for in packets (where some of\n  // those packets may possibly have had their time of arrival recorded).\n  int64_t bytes_observed_in_packets_;\n\n  // The request time may not be available when we are being destroyed, so we\n  // snapshot it early on.\n  base::Time request_time_snapshot_;\n\n  // Since we don't save all packet times in packet_times_, we save the\n  // last time for use in histograms.\n  base::Time final_packet_time_;\n\n  // The start time for the job, ignoring re-starts.\n  base::TimeTicks start_time_;\n\n  // When the transaction finished reading the request headers.\n  base::TimeTicks receive_headers_end_;\n\n  // We allow the network delegate to modify a copy of the response headers.\n  // This prevents modifications of headers that are shared with the underlying\n  // layers of the network stack.\n  scoped_refptr\u003cHttpResponseHeaders\u003e override_response_headers_;\n\n  // The network delegate can mark a URL as safe for redirection.\n  // The reference fragment of the original URL is not appended to the redirect\n  // URL when the redirect URL is equal to |allowed_unsafe_redirect_url_|.\n  GURL allowed_unsafe_redirect_url_;\n\n  // Flag used to verify that |this| is not deleted while we are awaiting\n  // a callback from the NetworkDelegate. Used as a fail-fast mechanism.\n  // True if we are waiting a callback and\n  // NetworkDelegate::NotifyURLRequestDestroyed has not been called, yet,\n  // to inform the NetworkDelegate that it may not call back.\n  bool awaiting_callback_;\n\n  const HttpUserAgentSettings* http_user_agent_settings_;\n\n  // Keeps track of total received bytes over the network from transactions used\n  // by this job that have already been destroyed.\n  int64_t total_received_bytes_from_previous_transactions_;\n  // Keeps track of total sent bytes over the network from transactions used by\n  // this job that have already been destroyed.\n  int64_t total_sent_bytes_from_previous_transactions_;\n\n  base::WeakPtrFactory\u003cURLRequestHttpJob\u003e weak_factory_;\n\n  DISALLOW_COPY_AND_ASSIGN(URLRequestHttpJob);\n};\n\n}  // namespace net\n\n#endif  // NET_URL_REQUEST_URL_REQUEST_HTTP_JOB_H_\n"},"gob_info":{"repo":"chromium/chromium/src","commit":"fe199f4407a2d90e1cd7d95b072896f17cfd0f97","path":"net/url_request/url_request_http_job.h"}}}],"elapsed_ms":12}